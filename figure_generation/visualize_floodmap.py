"""
Visualize flood maps from MODIS-based flood detection.

This script creates map visualizations of flood extent and duration from the
GeoTIFF files generated by the detect_flooded_pixels.py script. It displays
the flooded areas, flood duration, and administrative boundaries.

Inputs
------
- {mon-yr-adm1-id}.tif : Flood map GeoTIFF with 4 bands
- GAUL_2015/g2015_2014_1 : GAUL Level 1 administrative boundaries (optional)

Outputs
-------
- PNG figure saved to specified output directory
- Interactive display (if show=True)

Examples
--------
$ python visualize_floodmap.py ../data/example_floodmaps/02-2020-0089-USA-3238.tif
$ python visualize_floodmap.py ../data/example_floodmaps/02-2020-0089-USA-3238.tif --show

"""

import argparse
import os
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.colors import ListedColormap
import rioxarray as rio
import geopandas as gpd
import numpy as np
import contextily as cx

# Configuration: Variable to plot
# Options: "flooded", "duration", "clear_views", "clear_perc_scaled"
FLOOD_VARIABLE = "flooded"

# Configuration: Show admin boundary on map
SHOW_ADMIN_BOUNDARY = True

# Configuration: Default DPI for output figures
FIG_DPI = 500

# Configuration: Output directories
FIGS_DIR = "figs/"
FLOODMAP_DIR = f"{FIGS_DIR}floodmaps/"

# Configuration: Font settings
plt.rcParams["font.family"] = "Georgia"


def parse_args():
    """
    Parse command-line arguments.

    Returns
    -------
    argparse.Namespace
        Parsed arguments.
    """
    parser = argparse.ArgumentParser(
        description="Visualize flood maps from MODIS-based flood detection"
    )
    parser.add_argument(
        "flood_tif",
        help="Path to flood map GeoTIFF file (e.g., 07-2024-0544-SDN-2757.tif)",
    )
    parser.add_argument(
        "--gaul-path",
        default="../data/g2015_2014_1",
        help="Path to GAUL Level 1 shapefile directory (default: ../data/g2015_2014_1)",
    )
    parser.add_argument(
        "--show",
        action="store_true",
        help="Display figure interactively (default: False)",
    )
    parser.add_argument(
        "--dpi",
        type=int,
        default=FIG_DPI,
        help=f"DPI for saved figure (default: {FIG_DPI})",
    )
    return parser.parse_args()


def load_flood_data(tif_path):
    """
    Load flood map GeoTIFF and extract bands.

    Parameters
    ----------
    tif_path : str
        Path to the GeoTIFF file.

    Returns
    -------
    dict
        Dictionary with band names as keys and xarray DataArrays as values.
    """
    print(f"Loading flood data from {tif_path}...")

    # Open the raster
    flood_data = rio.open_rasterio(tif_path, masked=True)

    # Extract individual bands
    bands = {
        "flooded": flood_data.sel(band=1),
        "duration": flood_data.sel(band=2),
        "clear_views": flood_data.sel(band=3),
        "clear_perc_scaled": flood_data.sel(band=4),
    }

    # Count pixels based on the configured variable
    if FLOOD_VARIABLE == "flooded":
        num_pixels = np.sum(bands["flooded"] == 1).values
        pixel_label = "Flooded pixels"
    else:
        num_pixels = np.sum(bands[FLOOD_VARIABLE] > 0).values
        pixel_label = f"{FLOOD_VARIABLE} pixels"

    print(f"  Loaded {flood_data.shape[1]} x {flood_data.shape[2]} grid")
    print(f"  {pixel_label}: {num_pixels}")

    if num_pixels == 0:
        print(f"  WARNING: No pixels with {FLOOD_VARIABLE} > 0 found in this image!")

    return bands


def get_admin_boundary(tif_path, gaul_path):
    """
    Extract admin1 boundary for the flood event.

    Parameters
    ----------
    tif_path : str
        Path to flood TIF (filename contains admin code).
    gaul_path : str
        Path to GAUL Level 1 shapefile directory.

    Returns
    -------
    geopandas.GeoDataFrame or None
        Admin1 boundary or None if not found.
    """
    # Extract admin1 code from filename
    # Format: MM-YYYY-XXXX-CCC-##### where ##### is admin1 code
    filename = os.path.basename(tif_path)
    try:
        adm1_code = int(filename.split("-")[-1].replace(".tif", ""))
        print(f"Extracting boundary for admin1 code: {adm1_code}")

        # Load GAUL boundaries
        gaul = gpd.read_file(gaul_path)
        boundary = gaul[gaul["ADM1_CODE"] == adm1_code]

        if len(boundary) > 0:
            print(f"  Found boundary: {boundary.iloc[0]['ADM1_NAME']}")
            return boundary
        else:
            print(f"  Warning: No boundary found for code {adm1_code}")
            return None
    except Exception as e:
        print(f"  Warning: Could not extract boundary: {e}")
        return None


def create_flood_visualization(
    bands, boundary, event_id, output_path, dpi=150, show=False
):
    """
    Create a visualization of flood extent with basemap.

    Parameters
    ----------
    bands : dict
        Dictionary of flood bands.
    boundary : geopandas.GeoDataFrame or None
        Admin1 boundary (optional).
    event_id : str
        Event identifier for the title.
    output_path : str
        Path to save the figure.
    dpi : int
        DPI for saved figure.
    show : bool
        Whether to display the figure.
    """
    print("Creating visualization with basemap...")

    fig, ax = plt.subplots(1, 1, figsize=(12, 10))

    # Get the configured variable as raster
    data = bands[FLOOD_VARIABLE]

    # Reproject to Web Mercator for basemap
    data_web = data.rio.reproject("EPSG:3857")

    # Create masked array - only show pixels with data
    if FLOOD_VARIABLE == "flooded":
        data_masked = np.ma.masked_where(data_web.values != 1, data_web.values)
    else:
        data_masked = np.ma.masked_where(data_web.values <= 0, data_web.values)

    # Get extent for imshow
    left = float(data_web.x.min())
    right = float(data_web.x.max())
    bottom = float(data_web.y.min())
    top = float(data_web.y.max())
    extent = [left, right, bottom, top]

    # Plot pixels as raster
    if not data_masked.mask.all():  # Check if there are any pixels to display
        # Choose colormap based on variable
        if FLOOD_VARIABLE == "flooded":
            cmap = ListedColormap(["#0000FF"])
            label = "Flooded Pixels"
        elif FLOOD_VARIABLE == "duration":
            cmap = "YlOrRd"
            label = "Flood Duration (days)"
        else:
            cmap = "viridis"
            label = FLOOD_VARIABLE.replace("_", " ").title()

        im = ax.imshow(
            data_masked,
            extent=extent,
            origin="upper",
            cmap=cmap,
            alpha=0.7,
            zorder=2,
            interpolation="nearest",
        )

    # Add basemap
    cx.add_basemap(
        ax,
        crs="EPSG:3857",
        source=cx.providers.OpenStreetMap.Mapnik,
        zoom="auto",
        attribution=False,
    )

    # Add admin boundary if available and enabled
    if SHOW_ADMIN_BOUNDARY and boundary is not None:
        boundary_web = boundary.to_crs(epsg=3857)
        boundary_web.boundary.plot(ax=ax, color="red", linewidth=1, zorder=3)

    # Set title
    ax.set_title(f"Event ID: {event_id}", fontsize=22, pad=20)
    ax.set_axis_off()  # Turn off axis for cleaner look

    # Add legend
    if FLOOD_VARIABLE == "flooded":
        data_patch = mpatches.Patch(color="#0000FF", label=label, alpha=0.7)
        legend_handles = [data_patch]
    else:
        # For non-binary variables, skip the data patch (colorbar shows the scale)
        legend_handles = []

    if SHOW_ADMIN_BOUNDARY and boundary is not None:
        boundary_patch = mpatches.Patch(
            facecolor="none", edgecolor="red", label="Admin Boundary", linewidth=1
        )
        legend_handles.append(boundary_patch)

    if legend_handles:
        ax.legend(
            handles=legend_handles, loc="upper right", framealpha=0.9, fontsize=14
        )

    plt.tight_layout()

    # Save figure
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    plt.savefig(output_path, dpi=dpi, bbox_inches="tight", facecolor="white")
    print(f"  Saved figure to {output_path}")

    # Show if requested
    if show:
        plt.show()
    else:
        plt.close()


def main():
    """
    Main execution function.
    """
    args = parse_args()

    # Check if input file exists
    if not os.path.exists(args.flood_tif):
        raise FileNotFoundError(f"Flood TIF not found: {args.flood_tif}")

    # Extract event ID from filename
    event_id = os.path.basename(args.flood_tif).replace(".tif", "")

    # Load flood data
    bands = load_flood_data(args.flood_tif)

    # Get admin boundary (optional)
    boundary = None
    if os.path.exists(args.gaul_path):
        boundary = get_admin_boundary(args.flood_tif, args.gaul_path)
    else:
        print(f"Warning: GAUL path not found: {args.gaul_path}")

    # Create output path
    output_path = os.path.join(FLOODMAP_DIR, f"{event_id}_{FLOOD_VARIABLE}.png")

    # Create visualization
    create_flood_visualization(
        bands=bands,
        boundary=boundary,
        event_id=event_id,
        output_path=output_path,
        dpi=args.dpi,
        show=args.show,
    )

    print("\nVisualization complete!")


if __name__ == "__main__":
    main()
